const { Client, Intents, EmbedBuilder, IntentsBitField, ButtonBuilder, ButtonStyle, ActionRowBuilder, StringSelectMenuBuilder, StringSelectMenuOptionBuilder, ActivityType} = require('discord.js');
const axios = require('axios');

// Replace with your Discord bot token

require('dotenv').config()

// Create a new Discord client instance
// const client = new Client({ intents: [Intents.HUHFLAGS.GUILDS, Intents.FLAGS.GUILD_MESSAGES] });


const client = new Client({intents: [
    IntentsBitField.Flags.Guilds,
    IntentsBitField.Flags.GuildMembers,
    IntentsBitField.Flags.MessageContent,
    IntentsBitField.Flags.GuildMessageReactions,
    IntentsBitField.Flags.DirectMessages,
    IntentsBitField.Flags.GuildMessageTyping,
    IntentsBitField.Flags.GuildVoiceStates,
    IntentsBitField.Flags.GuildWebhooks,
    IntentsBitField.Flags.GuildInvites,
    IntentsBitField.Flags.GuildPresences,
    IntentsBitField.Flags.DirectMessageTyping,
    IntentsBitField.Flags.GuildMessages,
    IntentsBitField.Flags.GuildEmojisAndStickers,
    IntentsBitField.Flags.DirectMessageReactions,  
    ]});

// Event: When the bot has logged in successfully
let ready = false


client.once('ready', () => {
    if (ready) return
    ready = true
    console.log(`Logged in as ${client.user.tag}!`);



    async function changeActivity() {
        const randomActivities = [
            /*
        {
        type: ActivityType.Watching,
        name: `Roblox Exploits Status`,
        state: `ðŸŸ¢ /roblox exploit status`
        },
        */
                {
                    type: ActivityType.Custom,
                    name: `New Roblox Executor Updates Tracker! ðŸŒ âœ¨`,
                    },
                    {
                        type: ActivityType.Custom,
                        name: `âœ¨ðŸ”¥ New Commands! Expand to see them all. /roblox versions /roblox executor status`,
                        },

                        {
                            type: ActivityType.Watching,
                            name: `For Roblox Updates`,
                            },

        ]
        const randomActivity = randomActivities[Math.floor(Math.random() * randomActivities.length)];
    client.user.setActivity(randomActivity)
    }
changeActivity()
    setInterval(() => {
    changeActivity()
    }, 60000); //Updates every 1 minute

// Command handler


client.on("interactionCreate", async (interaction) => {
  // Fetch the current Android version from the API
if (interaction.isCommand()) {

    let subCommand = null
    let subCommandGroup = null
    try {
      subCommand = interaction.options.getSubcommand() || null
      subCommandGroup = interaction.options.getSubcommandGroup() || null
    } catch (error) {
      
    }
const { options, commandName } = interaction


  if (commandName === `roblox` && subCommand === `versions`) {
    await interaction.deferReply()


  const androidResponse = await axios.get('https://weao.xyz/api/versions/android', {
    headers: {
        'User-Agent': 'WEAO-3PService'
    } 
});

const windowsMacResponse = await axios.get('https://weao.xyz/api/versions/current', {
    headers: {
        'User-Agent': 'WEAO-3PService'
    } 
});

const windowsMacData = windowsMacResponse.data

const androidData = androidResponse.data;

const windowsVersion = windowsMacData.Windows


const windowsDate = windowsMacData.WindowsDate

const macVersion = windowsMacData.Mac

const macDate = windowsMacData.MacDate

const androidVersion = androidData.Android

const androidDate = androidData.AndroidDate


// Convert the Date object to a Unix timestamp (in seconds)
const androidTimestamp = Math.floor(new Date(androidDate).getTime() / 1000);

const macTimestamp = Math.floor(new Date(macDate).getTime() / 1000);

const windowsTimestamp = Math.floor(new Date(windowsDate).getTime() / 1000);

const robloxVersionsEmbed = new EmbedBuilder()
.setFields(
{name: `**<:android:1278151173161091132> Android Version**`, value: `\`\`\`${androidVersion}\`\`\`
**<:NewBuild:1277754500362272788> Build Update** 
<t:${androidTimestamp}:f>`},

{name: `**<:Windows:1278160616250413066> Windows Version**`, value: `\`\`\`${windowsVersion}\`\`\`
**<:NewBuild:1277754500362272788> Build Update** 
<t:${windowsTimestamp}:f>`},

{name: `**<:MacOS:1278160430438678572> MacOS Version**`, value: `\`\`\`${macVersion}\`\`\`
**<:NewBuild:1277754500362272788> Build Update** 
<t:${macTimestamp}:f>`},


//{name: `<:NewBuild:1277754500362272788> Build Updated`, value: `<t:${timestamp}:f>`, inline: true}

)
.setTitle(`Roblox Versions`)
.setColor(0x2B2D31)
.setFooter({text: `âœ¨ Powered by https://weao.xyz`, iconURL: 'https://cdn.discordapp.com/emojis/1278151154873925662.webp?size=60&quality=lossless'})
.setThumbnail(client.user.avatarURL())

interaction.editReply({embeds: [robloxVersionsEmbed]})
  } else if (commandName === `roblox` && subCommandGroup === `executor` && subCommand === `status`) {
   await interaction.deferReply()
    const statusResponse = await axios.get('https://weao.xyz/api/status/exploits', {
        headers: {
            'User-Agent': 'WEAO-3PService'
        } 
    })

    //let statusColor = 0x39FF8D


    const robloxExploitStatus = new EmbedBuilder()
    //.setColor(0x2B2D31)
    .setColor(0x281A50)
    .setTitle(`Services`)
    .setFooter({text: `âœ¨ Powered by https://weao.xyz`, iconURL: `https://cdn.discordapp.com/emojis/1278169998514192384.webp?size=60&quality=lossless`})

    let servicesDown = []


    //console.log(statusResponse)

    statusResponse.data.forEach(exploit => {
        if (robloxExploitStatus.toJSON().fields && robloxExploitStatus.toJSON().fields.length === 25) {
        return;
        }

        let status = `<:operational:1278169998514192384>`

        if (!exploit.updateStatus) {
        status = `<:outage:1278170465965445161>`
        servicesDown.push(exploit.title)
        }

        robloxExploitStatus.addFields(
        {name: `**${exploit.title}**`, value: status + ` **${exploit.version}** **${exploit.websitelink || exploit.discordlink}**`, inline: true}
        )

        
    });


    const systemStatus = new ButtonBuilder()
    .setCustomId(`system_status`)
    .setStyle(ButtonStyle.Success)
    .setLabel(`All Systems Operational!`)
    .setDisabled(true)


    const infoBar = new StringSelectMenuBuilder()
    .setPlaceholder(`Service Outages`)
    .setCustomId(`clear:info`)
    .setMinValues(1)

    if (servicesDown.length !== 0) {
    systemStatus.setStyle(ButtonStyle.Danger)
    systemStatus.setLabel(`Some Services are having a major outage!`)
    //systemStatus.setEmoji({name:`â›”`})

    statusResponse.data.forEach(exploit => {
    const exploitIsDown = !exploit.updateStatus

    if (exploitIsDown) {
    if (infoBar.options && infoBar.options.length === 25) return
    infoBar.addOptions(
    new StringSelectMenuOptionBuilder()
    .setEmoji({id:`1278170465965445161`})
    .setDescription(`This service is having an outage`)
    .setLabel(`${exploit.title} ${exploit.version}`)
    .setValue(`info_${exploit.title}`)
    )
    }
    });
    }
    
    
 const components = [new ActionRowBuilder().setComponents(systemStatus)]

 if (servicesDown.length !== 0) {
    components.push(new ActionRowBuilder().setComponents(infoBar))
 }
 await interaction.editReply({components: components})

 try {
    await interaction.channel.send({embeds: [robloxExploitStatus]})
    } catch (error) {
        
    }





  }
} else if (interaction.isStringSelectMenu()) {
    const { customId } = interaction
    if (customId === `clear:info`) {
        interaction.update({components: interaction.message.components})
    }
}

})
        
        
})
          

// Log in to Discord with the bot's token

client.login(process.env.TOKEN);
